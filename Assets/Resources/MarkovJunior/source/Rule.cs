// Copyright (C) 2022 Maxim Gumin, The MIT License (MIT)

using System.Linq;
using System.Xml.Linq;
using System.Collections.Generic;

namespace MarkovJunior
{

    /// <summary>
    /// Represents a single rewrite rule, with an input pattern and an output
    /// pattern. The input pattern may have wildcards and unions, which can match
    /// multiple colors; the output pattern may have wildcards, which are not
    /// written to the grid when the rule is applied.
    /// </summary>
    class Rule
    {
        /// <summary>The width of the input pattern.</summary>
        public int IMX;

        /// <summary>The height of the input pattern.</summary>
        public int IMY;

        /// <summary>The depth of the input pattern. A 2D pattern has a depth of 1.</summary>
        public int IMZ;

        /// <summary>The width of the output pattern.</summary>
        public int OMX;

        /// <summary>The height of the output pattern.</summary>
        public int OMY;

        /// <summary>The depth of the output pattern. A 2D pattern has a depth of 1.</summary>
        public int OMZ;

        /// <summary>The input pattern, as a flat array of bitmasks.</summary>
        public int[] input;

        /// <summary>The output pattern, as a flat array. Wildcards are represented as <c>0xff</c>.</summary>
        public byte[] output;

        /// <summary>
        /// The input pattern, as a flat array. Wildcards are represented as
        /// <c>0xff</c>; unions are replaced with their lowest member.
        /// </summary>
        public byte[] binput;

        /// <summary>
        /// The probability that this rule will be applied. Only used by
        /// <see cref="ParallelNode">ParallelNode</see>.
        /// </summary>
        public double p;

        /// <summary>
        /// The offsets for each color in the input pattern. <c>ishifts[c]</c>
        /// contains (x, y, z) if and only if the color <c>c</c> matches at that
        /// position in the input pattern (allowing for wildcards and unions).
        /// </summary>
        public (int, int, int)[][] ishifts;

        /// <summary>
        /// The offsets for each color in the output pattern. <c>oshifts[c]</c>
        /// contains (x, y, z) if and only if the color <c>c</c> can occur at that
        /// position in the output pattern (allowing for wildcards).
        /// </summary>
        public (int, int, int)[][] oshifts;

        /// <summary>
        /// A rule is 'original' if it appears in the program's source code;
        /// otherwise, the rule was generated by symmetry and is not 'original'.
        /// </summary>
        public bool original;

        /// <param name="input"><inheritdoc cref="input" path="/summary"/></param>
        /// <param name="IMX"><inheritdoc cref="IMX" path="/summary"/></param>
        /// <param name="IMY"><inheritdoc cref="IMY" path="/summary"/></param>
        /// <param name="IMZ"><inheritdoc cref="IMZ" path="/summary"/></param>
        /// <param name="output"><inheritdoc cref="output" path="/summary"/></param>
        /// <param name="OMX"><inheritdoc cref="OMX" path="/summary"/></param>
        /// <param name="OMY"><inheritdoc cref="OMY" path="/summary"/></param>
        /// <param name="OMZ"><inheritdoc cref="OMZ" path="/summary"/></param>
        /// <param name="C"><inheritdoc cref="Grid.C" path="/summary"/></param>
        /// <param name="p"><inheritdoc cref="p" path="/summary"/></param>
        public Rule(int[] input, int IMX, int IMY, int IMZ, byte[] output, int OMX, int OMY, int OMZ, int C, double p)
        {
            this.input = input;
            this.output = output;
            this.IMX = IMX;
            this.IMY = IMY;
            this.IMZ = IMZ;
            this.OMX = OMX;
            this.OMY = OMY;
            this.OMZ = OMZ;

            this.p = p;

            // build ishifts array
            List<(int, int, int)>[] lists = new List<(int, int, int)>[C];
            for (int c = 0; c < C; c++) lists[c] = new List<(int, int, int)>();
            for (int z = 0; z < IMZ; z++) for (int y = 0; y < IMY; y++) for (int x = 0; x < IMX; x++)
                    {
                        int w = input[x + y * IMX + z * IMX * IMY];
                        for (int c = 0; c < C; c++, w >>= 1) if ((w & 1) == 1) lists[c].Add((x, y, z));
                    }
            ishifts = new (int, int, int)[C][];
            for (int c = 0; c < C; c++) ishifts[c] = lists[c].ToArray();

            // build oshifts array
            if (OMX == IMX && OMY == IMY && OMZ == IMZ)
            {
                for (int c = 0; c < C; c++) lists[c].Clear();
                for (int z = 0; z < OMZ; z++) for (int y = 0; y < OMY; y++) for (int x = 0; x < OMX; x++)
                        {
                            byte o = output[x + y * OMX + z * OMX * OMY];
                            if (o != 0xff) lists[o].Add((x, y, z));
                            else for (int c = 0; c < C; c++) lists[c].Add((x, y, z));
                        }
                oshifts = new (int, int, int)[C][];
                for (int c = 0; c < C; c++) oshifts[c] = lists[c].ToArray();
            }

            // build binput array
            int wildcard = (1 << C) - 1;
            binput = new byte[input.Length];
            for (int i = 0; i < input.Length; i++)
            {
                int w = input[i];
                binput[i] = w == wildcard ? (byte)0xff : Helper.FirstNonZeroPosition(w);
            }
        }

        /// <summary>
        /// Returns a new rule by rotating this one about the z axis.
        /// </summary>
        public Rule ZRotated()
        {
            int[] newinput = new int[input.Length];
            for (int z = 0; z < IMZ; z++) for (int y = 0; y < IMX; y++) for (int x = 0; x < IMY; x++)
                        newinput[x + y * IMY + z * IMX * IMY] = input[IMX - 1 - y + x * IMX + z * IMX * IMY];

            byte[] newoutput = new byte[output.Length];
            for (int z = 0; z < OMZ; z++) for (int y = 0; y < OMX; y++) for (int x = 0; x < OMY; x++)
                        newoutput[x + y * OMY + z * OMX * OMY] = output[OMX - 1 - y + x * OMX + z * OMX * OMY];

            return new Rule(newinput, IMY, IMX, IMZ, newoutput, OMY, OMX, OMZ, ishifts.Length, p);
        }

        /// <summary>
        /// Returns a new rule by rotating this one about the y axis.
        /// </summary>
        public Rule YRotated()
        {
            int[] newinput = new int[input.Length];
            for (int z = 0; z < IMX; z++) for (int y = 0; y < IMY; y++) for (int x = 0; x < IMZ; x++)
                        newinput[x + y * IMZ + z * IMZ * IMY] = input[IMX - 1 - z + y * IMX + x * IMX * IMY];

            byte[] newoutput = new byte[output.Length];
            for (int z = 0; z < OMX; z++) for (int y = 0; y < OMY; y++) for (int x = 0; x < OMZ; x++)
                        newoutput[x + y * OMZ + z * OMZ * OMY] = output[OMX - 1 - z + y * OMX + x * OMX * OMY];

            return new Rule(newinput, IMZ, IMY, IMX, newoutput, OMZ, OMY, OMX, ishifts.Length, p);
        }

        /// <summary>
        /// Returns a new rule by reflecting this one in the x axis.
        /// </summary>
        public Rule Reflected()
        {
            int[] newinput = new int[input.Length];
            for (int z = 0; z < IMZ; z++) for (int y = 0; y < IMY; y++) for (int x = 0; x < IMX; x++)
                        newinput[x + y * IMX + z * IMX * IMY] = input[IMX - 1 - x + y * IMX + z * IMX * IMY];

            byte[] newoutput = new byte[output.Length];
            for (int z = 0; z < OMZ; z++) for (int y = 0; y < OMY; y++) for (int x = 0; x < OMX; x++)
                        newoutput[x + y * OMX + z * OMX * OMY] = output[OMX - 1 - x + y * OMX + z * OMX * OMY];

            return new Rule(newinput, IMX, IMY, IMZ, newoutput, OMX, OMY, OMZ, ishifts.Length, p);
        }

        /// <summary>
        /// Determines whether two rules are equal by value.
        /// </summary>
        public static bool Same(Rule a1, Rule a2)
        {
            if (a1.IMX != a2.IMX || a1.IMY != a2.IMY || a1.IMZ != a2.IMZ || a1.OMX != a2.OMX || a1.OMY != a2.OMY || a1.OMZ != a2.OMZ) return false;
            for (int i = 0; i < a1.IMX * a1.IMY * a1.IMZ; i++) if (a1.input[i] != a2.input[i]) return false;
            for (int i = 0; i < a1.OMX * a1.OMY * a1.OMZ; i++) if (a1.output[i] != a2.output[i]) return false;
            return true;
        }

        /// <summary>
        /// Returns an enumerable of symmetric counterparts of this rule.
        /// </summary>
        /// <param name="symmetry">An array of flags defining a subgroup of symmetries.</param>
        /// <param name="d2">If <c>true</c>, only 2D symmetries are generated; otherwise, 3D symmetries are generated.</param>
        public IEnumerable<Rule> Symmetries(bool[] symmetry, bool d2)
        {
            if (d2) return SymmetryHelper.SquareSymmetries(this, r => r.ZRotated(), r => r.Reflected(), Same, symmetry);
            else return SymmetryHelper.CubeSymmetries(this, r => r.ZRotated(), r => r.YRotated(), r => r.Reflected(), Same, symmetry);
        }

        public static (char[] data, int MX, int MY, int MZ) LoadResource(string filename, string legend, bool d2)
        {
            if (legend == null)
            {
                Interpreter.WriteLine($"no legend for {filename}");
                return (null, -1, -1, -1);
            }
            (int[] data, int MX, int MY, int MZ) = d2 ? Graphics.LoadBitmap(filename) : VoxHelper.LoadVox(filename);

            if (data == null)
            {
                Interpreter.WriteLine($"couldn't read {filename}");
                return (null, MX, MY, MZ);
            }
            (byte[] ords, int amount) = data.Ords();
            if (amount > legend.Length)
            {
                Interpreter.WriteLine($"the amount of colors {amount} in {filename} is more than {legend.Length}");
                return (null, MX, MY, MZ);
            }
            // for (int o = 0; o < data.Length; o++)
            //     UnityEngine.Debug.Log(data[o]);
            return (ords.Select(o => legend[o]).ToArray(), MX, MY, MZ);
        }

        /// <summary>
        /// Parses a pattern from a string, returning a flat array of characters,
        /// and the pattern's width, height and depth. If the pattern cannot be
        /// parsed, then <c>(null, -1, -1, -1)</c> is returned.
        /// </summary>
        static (char[], int, int, int) Parse(string s)
        {
            string[][] lines = Helper.Split(s, ' ', '/');
            int MX = lines[0][0].Length;
            int MY = lines[0].Length;
            int MZ = lines.Length;
            char[] result = new char[MX * MY * MZ];

            for (int z = 0; z < MZ; z++)
            {
                string[] linesz = lines[MZ - 1 - z];
                if (linesz.Length != MY)
                {
                    Interpreter.Write("non-rectangular pattern");
                    return (null, -1, -1, -1);
                }
                for (int y = 0; y < MY; y++)
                {
                    string lineszy = linesz[y];
                    if (lineszy.Length != MX)
                    {
                        Interpreter.Write("non-rectangular pattern");
                        return (null, -1, -1, -1);
                    }
                    for (int x = 0; x < MX; x++) result[x + y * MX + z * MX * MY] = lineszy[x];
                }
            }

            return (result, MX, MY, MZ);
        }

        /// <summary>
        /// Loads a rewrite rule from an XML element. The loading may fail if the
        /// XML data is invalid, or a referenced resource file cannot be loaded, in
        /// which case <c>null</c> is returned.
        /// </summary>
        /// <param name="xelem">The XML element.</param>
        /// <param name="gin">The grid which the input pattern will be matched against.</param>
        /// <param name="gout">The grid which the output pattern will be written to. This is usually the same as <c>gin</c>.</param>
        public static Rule Load(XElement xelem, Grid gin, Grid gout)
        {
            int lineNumber = xelem.LineNumber();
            string filepath(string name)
            {
                string result = "resources/rules/";
                if (gout.folder != null) result += gout.folder + "/";
                result += name;
                result += gin.MZ == 1 ? ".png" : ".vox";
                return result;
            };

            string inString = xelem.Get<string>("in", null);
            string outString = xelem.Get<string>("out", null);
            string finString = xelem.Get<string>("fin", null);
            string foutString = xelem.Get<string>("fout", null);
            string fileString = xelem.Get<string>("file", null);
            string legend = xelem.Get<string>("legend", null);

            char[] inRect, outRect;
            int IMX = -1, IMY = -1, IMZ = -1, OMX = -1, OMY = -1, OMZ = -1;
            if (fileString == null)
            {
                if (inString == null && finString == null)
                {
                    Interpreter.WriteLine($"no input in a rule at line {lineNumber}");
                    return null;
                }
                if (outString == null && foutString == null)
                {
                    Interpreter.WriteLine($"no output in a rule at line {lineNumber}");
                    return null;
                }

                (inRect, IMX, IMY, IMZ) = inString != null ? Parse(inString) : LoadResource(filepath(finString), legend, gin.MZ == 1);
                if (inRect == null)
                {
                    Interpreter.WriteLine($" in input at line {lineNumber}");
                    return null;
                }

                (outRect, OMX, OMY, OMZ) = outString != null ? Parse(outString) : LoadResource(filepath(foutString), legend, gin.MZ == 1);
                if (outRect == null)
                {
                    Interpreter.WriteLine($" in output at line {lineNumber}");
                    return null;
                }

                if (gin == gout && (OMZ != IMZ || OMY != IMY || OMX != IMX))
                {
                    Interpreter.WriteLine($"non-matching pattern sizes at line {lineNumber}");
                    return null;
                }
            }
            else
            {
                if (inString != null || finString != null || outString != null || foutString != null)
                {
                    Interpreter.WriteLine($"rule at line {lineNumber} already contains a file attribute");
                    return null;
                }
                (char[] rect, int FX, int FY, int FZ) = LoadResource(filepath(fileString), legend, gin.MZ == 1);
                if (rect == null)
                {
                    Interpreter.WriteLine($" in a rule at line {lineNumber}");
                    return null;
                }
                if (FX % 2 != 0)
                {
                    Interpreter.WriteLine($"odd width {FX} in {fileString}");
                    return null;
                }

                IMX = OMX = FX / 2;
                IMY = OMY = FY;
                IMZ = OMZ = FZ;
                // for (int o = 0; o < rect.Length; o++)
                //     UnityEngine.Debug.Log(rect[o]);
                inRect = AH.FlatArray3D(FX / 2, FY, FZ, (x, y, z) => rect[x + y * FX + z * FX * FY]);
                outRect = AH.FlatArray3D(FX / 2, FY, FZ, (x, y, z) => rect[x + FX / 2 + y * FX + z * FX * FY]);
            }

            int[] input = new int[inRect.Length];
            for (int i = 0; i < inRect.Length; i++)
            {
                char c = inRect[i];
                bool success = gin.waves.TryGetValue(c, out int value);
                if (!success)
                {
                    Interpreter.WriteLine($"input code {c} at line {lineNumber} is not found in codes");
                    return null;
                }
                input[i] = value;
            }

            byte[] output = new byte[outRect.Length];
            for (int o = 0; o < outRect.Length; o++)
            {
                char c = outRect[o];
                if (c == '*') output[o] = 0xff;
                else
                {
                    bool success = gout.values.TryGetValue(c, out byte value);
                    if (!success)
                    {
                        Interpreter.WriteLine($"output code {c} at line {lineNumber} is not found in codes");
                        return null;
                    }

                    output[o] = value;
                }
                // Interpreter.WriteLine($"output code {c} at line {lineNumber} is found in codes");
            }
            // Interpreter.WriteLine(outRect.Length.ToString());

            double p = xelem.Get("p", 1.0);
            return new Rule(input, IMX, IMY, IMZ, output, OMX, OMY, OMZ, gin.C, p);
        }
    }
}